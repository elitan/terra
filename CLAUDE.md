# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# pgterra Development Philosophy & Guidelines

## Core Philosophy: Declarative Schema Management

pgterra is a **declarative** PostgreSQL schema management tool. This means:

### ✅ What We Support (Declarative)

Users define the **desired end state** of their database schema:

```sql
-- GOOD: Declarative - defines what the schema should look like
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  title VARCHAR(255) NOT NULL,
  CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### ❌ What We DON'T Support (Imperative)

We do NOT support imperative statements that describe how to change the schema:

```sql
-- BAD: Imperative - describes steps to change schema
ALTER TABLE users ADD COLUMN email VARCHAR(255);
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
ALTER TABLE posts ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);
DROP TABLE old_table;
```

## Why This Matters

1. **Simplicity**: Users only need to think about their desired schema, not migration steps
2. **Idempotency**: Running the same schema file multiple times produces the same result
3. **Version Control**: Schema files represent complete states, making diffs meaningful
4. **Reliability**: pgterra figures out the optimal migration path automatically

## Handling Complex Scenarios

### Circular Foreign Keys

For circular dependencies, use inline constraint syntax:

```sql
-- Tables can reference each other using inline constraints
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  manager_id INTEGER REFERENCES employees(id),  -- Self-reference
  department_id INTEGER,
  CONSTRAINT fk_department FOREIGN KEY (department_id) REFERENCES departments(id)
);

CREATE TABLE departments (
  id SERIAL PRIMARY KEY,
  head_employee_id INTEGER,
  CONSTRAINT fk_head FOREIGN KEY (head_employee_id) REFERENCES employees(id)
);
```

### Schema Evolution

Users provide complete schema snapshots at different points in time:

```sql
-- schema-v1.sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

-- schema-v2.sql (complete schema, not just changes)
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(255) NOT NULL  -- New column
);
```

## Parser Implementation Guidelines

### DO:
- Parse `CREATE TABLE` statements with all inline constraints
- Parse `CREATE INDEX` statements
- Support all PostgreSQL constraint types inline (PRIMARY KEY, FOREIGN KEY, CHECK, UNIQUE)
- Parse complete schema definitions

### DON'T:
- Parse `ALTER TABLE` statements
- Parse `DROP` statements (except when generated by the differ)
- Support migration-specific syntax
- Add imperative constructs

### Example Parser Check:

```typescript
// In parser.ts
if (statement.type === "alter_table_stmt") {
  throw new Error(
    "ALTER TABLE statements are not supported. " +
    "Please define your complete desired schema using CREATE TABLE statements."
  );
}
```

## Testing Philosophy

Tests should use declarative schema definitions:

```typescript
// GOOD: Test with complete schema
test("should handle foreign keys", async () => {
  const schema = `
    CREATE TABLE users (
      id SERIAL PRIMARY KEY
    );
    CREATE TABLE posts (
      id SERIAL PRIMARY KEY,
      user_id INTEGER,
      CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id)
    );
  `;
  await schemaService.apply(schema);
});

// BAD: Don't test with ALTER statements
test("should add foreign key", async () => {
  const schema = `
    CREATE TABLE users (id SERIAL PRIMARY KEY);
    CREATE TABLE posts (id SERIAL PRIMARY KEY, user_id INTEGER);
    ALTER TABLE posts ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);
  `;
  // This should not be supported!
});
```

## User Documentation

Always remind users that pgterra is declarative:

- "Define what you want, not how to get there"
- "Your schema file should represent the complete desired state"
- "pgterra figures out the migration steps automatically"

## Migration Generation

The **differ** is responsible for generating any necessary `ALTER`, `DROP`, or other imperative statements. Users never write these directly.

## Summary

pgterra follows the same philosophy as Terraform, Kubernetes, and other modern infrastructure tools: **declarative configuration**. This makes schemas easier to understand, version control, and maintain.

# Development Commands

## Testing
ALWAYS use `bun test` to run tests, not `npm test`.

### Database Testing Requirements
**IMPORTANT**: All integration tests require a live PostgreSQL database. The test suite includes:
- **Unit tests** (parsing, SQL generation): Work without database ✅
- **Integration tests** (SchemaService, database operations): **Require database** ❌ without DB

### Running Tests with Live Database
1. **Start PostgreSQL database**:
   ```bash
   docker compose up -d
   ```

2. **Set DATABASE_URL environment variable**:
   ```bash
   export DATABASE_URL="postgres://test_user:test_password@localhost:5487/sql_terraform_test"
   ```

3. **Run tests**:
   ```bash
   # All tests
   bun test src/test/

   # Specific test suites
   bun test src/test/views/                    # All VIEW tests
   bun test src/test/views/basic-views.test.ts # Basic VIEW functionality
   bun test src/test/views/realistic-business-scenarios.test.ts # Business scenarios
   ```

4. **Verify database is ready**:
   ```bash
   bun run src/test/setup.ts
   ```

### Test Database Configuration
- **Host**: localhost:5487
- **Database**: sql_terraform_test  
- **User**: test_user
- **Password**: test_password
- **Docker container**: Defined in `docker-compose.yml`

### Without Database
Only unit tests (parsing, SQL generation) will pass. Integration tests will fail with connection errors.

### Common test commands:
- `bun test` - Run main test suite (tables, columns, indexes, constraints)
- `bun run test:watch` - Run tests in watch mode
- `bun run test:performance` - Run performance tests
- `bun run test:full` - Run full test suite with Docker setup
- `bun run test:setup:local` - Start Docker containers and setup test DB
- `bun run test:teardown` - Stop Docker containers
- `bun run test:constraints` - Run constraint-specific tests
- `bun run test:dependencies` - Run dependency resolution tests
- `bun run test:destructive` - Run destructive operation tests

## Development
- `bun run dev` - Run in development mode with file watching
- `bun run build` - Build for production
- `bun run plan` - Run the plan command (preview schema changes)
- `bun run apply` - Run the apply command (execute schema changes)

## Project Structure

The codebase follows a layered architecture:

### Core Components
- **Parser** (`src/core/schema/parser.ts`): Parses SQL schema definitions using `sql-parser-cst`
- **Differ** (`src/core/schema/differ.ts`): Compares desired vs current schema and generates migration plans
- **Database Client** (`src/core/database/client.ts`): Handles PostgreSQL connections and queries
- **Schema Service** (`src/core/schema/service.ts`): Orchestrates parsing, diffing, and applying changes
- **Migration Executor** (`src/core/migration/executor.ts`): Executes migration statements safely
- **Dependency Resolver** (`src/core/schema/dependency-resolver.ts`): Handles table dependency ordering

### CLI Layer
- **Commands** (`src/cli/commands/`): Command implementations (plan, apply)
- **CLI Entry** (`src/cli/index.ts`): Command-line interface setup using Commander.js

### Type System
- **Schema Types** (`src/types/schema.ts`): Core schema object definitions (Table, Column, Index, etc.)
- **Migration Types** (`src/types/migration.ts`): Migration plan and execution types
- **Config Types** (`src/types/config.ts`): Configuration and database connection types

### Key Dependencies
- `sql-parser-cst`: PostgreSQL SQL parsing
- `pg`: PostgreSQL client
- `commander`: CLI framework
- `chalk`: Terminal colors
- `diff`: Text diffing for migration display

## Architecture Principles

### Schema Objects
The system represents database schemas as TypeScript objects:
- `Table`: Contains columns, constraints, and indexes
- `Column`: Defines name, type, nullable, default
- Constraints: PrimaryKey, ForeignKey, Check, Unique
- `Index`: Supports btree, gin, gist, partial, expression-based

### Migration Flow
1. Parse desired schema from SQL files
2. Inspect current database schema
3. Generate diff/migration plan
4. Execute migration statements in correct order
5. Handle dependencies and circular references

### Error Handling
- Parser validates and rejects imperative SQL statements
- Migration executor provides rollback capabilities
- Destructive operations require explicit confirmation
- Data integrity validation before schema changes